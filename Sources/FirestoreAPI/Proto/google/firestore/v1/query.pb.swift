// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/firestore/v1/query.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A Firestore query.
///
/// The query stages are executed in the following order:
/// 1. from
/// 2. where
/// 3. select
/// 4. order_by + start_at + end_at
/// 5. offset
/// 6. limit
public struct Google_Firestore_V1_StructuredQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional sub-set of the fields to return.
  ///
  /// This acts as a [DocumentMask][google.firestore.v1.DocumentMask] over the
  /// documents returned from a query. When not set, assumes that the caller
  /// wants all fields returned.
  public var select: Google_Firestore_V1_StructuredQuery.Projection {
    get {return _storage._select ?? Google_Firestore_V1_StructuredQuery.Projection()}
    set {_uniqueStorage()._select = newValue}
  }
  /// Returns true if `select` has been explicitly set.
  public var hasSelect: Bool {return _storage._select != nil}
  /// Clears the value of `select`. Subsequent reads from it will return its default value.
  public mutating func clearSelect() {_uniqueStorage()._select = nil}

  /// The collections to query.
  public var from: [Google_Firestore_V1_StructuredQuery.CollectionSelector] {
    get {return _storage._from}
    set {_uniqueStorage()._from = newValue}
  }

  /// The filter to apply.
  public var `where`: Google_Firestore_V1_StructuredQuery.Filter {
    get {return _storage._where ?? Google_Firestore_V1_StructuredQuery.Filter()}
    set {_uniqueStorage()._where = newValue}
  }
  /// Returns true if ``where`` has been explicitly set.
  public var hasWhere: Bool {return _storage._where != nil}
  /// Clears the value of ``where``. Subsequent reads from it will return its default value.
  public mutating func clearWhere() {_uniqueStorage()._where = nil}

  /// The order to apply to the query results.
  ///
  /// Firestore allows callers to provide a full ordering, a partial ordering, or
  /// no ordering at all. In all cases, Firestore guarantees a stable ordering
  /// through the following rules:
  ///
  ///  * The `order_by` is required to reference all fields used with an
  ///    inequality filter.
  ///  * All fields that are required to be in the `order_by` but are not already
  ///    present are appended in lexicographical ordering of the field name.
  ///  * If an order on `__name__` is not specified, it is appended by default.
  ///
  /// Fields are appended with the same sort direction as the last order
  /// specified, or 'ASCENDING' if no order was specified. For example:
  ///
  ///  * `ORDER BY a` becomes `ORDER BY a ASC, __name__ ASC`
  ///  * `ORDER BY a DESC` becomes `ORDER BY a DESC, __name__ DESC`
  ///  * `WHERE a > 1` becomes `WHERE a > 1 ORDER BY a ASC, __name__ ASC`
  ///  * `WHERE __name__ > ... AND a > 1` becomes
  ///     `WHERE __name__ > ... AND a > 1 ORDER BY a ASC, __name__ ASC`
  public var orderBy: [Google_Firestore_V1_StructuredQuery.Order] {
    get {return _storage._orderBy}
    set {_uniqueStorage()._orderBy = newValue}
  }

  /// A potential prefix of a position in the result set to start the query at.
  ///
  /// The ordering of the result set is based on the `ORDER BY` clause of the
  /// original query.
  ///
  /// ```
  /// SELECT * FROM k WHERE a = 1 AND b > 2 ORDER BY b ASC, __name__ ASC;
  /// ```
  ///
  /// This query's results are ordered by `(b ASC, __name__ ASC)`.
  ///
  /// Cursors can reference either the full ordering or a prefix of the location,
  /// though it cannot reference more fields than what are in the provided
  /// `ORDER BY`.
  ///
  /// Continuing off the example above, attaching the following start cursors
  /// will have varying impact:
  ///
  /// - `START BEFORE (2, /k/123)`: start the query right before `a = 1 AND
  ///    b > 2 AND __name__ > /k/123`.
  /// - `START AFTER (10)`: start the query right after `a = 1 AND b > 10`.
  ///
  /// Unlike `OFFSET` which requires scanning over the first N results to skip,
  /// a start cursor allows the query to begin at a logical position. This
  /// position is not required to match an actual result, it will scan forward
  /// from this position to find the next document.
  ///
  /// Requires:
  ///
  /// * The number of values cannot be greater than the number of fields
  ///   specified in the `ORDER BY` clause.
  public var startAt: Google_Firestore_V1_Cursor {
    get {return _storage._startAt ?? Google_Firestore_V1_Cursor()}
    set {_uniqueStorage()._startAt = newValue}
  }
  /// Returns true if `startAt` has been explicitly set.
  public var hasStartAt: Bool {return _storage._startAt != nil}
  /// Clears the value of `startAt`. Subsequent reads from it will return its default value.
  public mutating func clearStartAt() {_uniqueStorage()._startAt = nil}

  /// A potential prefix of a position in the result set to end the query at.
  ///
  /// This is similar to `START_AT` but with it controlling the end position
  /// rather than the start position.
  ///
  /// Requires:
  ///
  /// * The number of values cannot be greater than the number of fields
  ///   specified in the `ORDER BY` clause.
  public var endAt: Google_Firestore_V1_Cursor {
    get {return _storage._endAt ?? Google_Firestore_V1_Cursor()}
    set {_uniqueStorage()._endAt = newValue}
  }
  /// Returns true if `endAt` has been explicitly set.
  public var hasEndAt: Bool {return _storage._endAt != nil}
  /// Clears the value of `endAt`. Subsequent reads from it will return its default value.
  public mutating func clearEndAt() {_uniqueStorage()._endAt = nil}

  /// The number of documents to skip before returning the first result.
  ///
  /// This applies after the constraints specified by the `WHERE`, `START AT`, &
  /// `END AT` but before the `LIMIT` clause.
  ///
  /// Requires:
  ///
  /// * The value must be greater than or equal to zero if specified.
  public var offset: Int32 {
    get {return _storage._offset}
    set {_uniqueStorage()._offset = newValue}
  }

  /// The maximum number of results to return.
  ///
  /// Applies after all other constraints.
  ///
  /// Requires:
  ///
  /// * The value must be greater than or equal to zero if specified.
  public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _storage._limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_uniqueStorage()._limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return _storage._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {_uniqueStorage()._limit = nil}

  /// Optional. A potential nearest neighbors search.
  ///
  /// Applies after all other filters and ordering.
  ///
  /// Finds the closest vector embeddings to the given query vector.
  public var findNearest: Google_Firestore_V1_StructuredQuery.FindNearest {
    get {return _storage._findNearest ?? Google_Firestore_V1_StructuredQuery.FindNearest()}
    set {_uniqueStorage()._findNearest = newValue}
  }
  /// Returns true if `findNearest` has been explicitly set.
  public var hasFindNearest: Bool {return _storage._findNearest != nil}
  /// Clears the value of `findNearest`. Subsequent reads from it will return its default value.
  public mutating func clearFindNearest() {_uniqueStorage()._findNearest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A sort direction.
  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Ascending.
    case ascending // = 1

    /// Descending.
    case descending // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .ascending
      case 2: self = .descending
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .ascending: return 1
      case .descending: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A selection of a collection, such as `messages as m1`.
  public struct CollectionSelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The collection ID.
    /// When set, selects only collections with this ID.
    public var collectionID: String = String()

    /// When false, selects only collections that are immediate children of
    /// the `parent` specified in the containing `RunQueryRequest`.
    /// When true, selects all descendant collections.
    public var allDescendants: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A filter.
  public struct Filter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of filter.
    public var filterType: Google_Firestore_V1_StructuredQuery.Filter.OneOf_FilterType? = nil

    /// A composite filter.
    public var compositeFilter: Google_Firestore_V1_StructuredQuery.CompositeFilter {
      get {
        if case .compositeFilter(let v)? = filterType {return v}
        return Google_Firestore_V1_StructuredQuery.CompositeFilter()
      }
      set {filterType = .compositeFilter(newValue)}
    }

    /// A filter on a document field.
    public var fieldFilter: Google_Firestore_V1_StructuredQuery.FieldFilter {
      get {
        if case .fieldFilter(let v)? = filterType {return v}
        return Google_Firestore_V1_StructuredQuery.FieldFilter()
      }
      set {filterType = .fieldFilter(newValue)}
    }

    /// A filter that takes exactly one argument.
    public var unaryFilter: Google_Firestore_V1_StructuredQuery.UnaryFilter {
      get {
        if case .unaryFilter(let v)? = filterType {return v}
        return Google_Firestore_V1_StructuredQuery.UnaryFilter()
      }
      set {filterType = .unaryFilter(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of filter.
    public enum OneOf_FilterType: Equatable {
      /// A composite filter.
      case compositeFilter(Google_Firestore_V1_StructuredQuery.CompositeFilter)
      /// A filter on a document field.
      case fieldFilter(Google_Firestore_V1_StructuredQuery.FieldFilter)
      /// A filter that takes exactly one argument.
      case unaryFilter(Google_Firestore_V1_StructuredQuery.UnaryFilter)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_StructuredQuery.Filter.OneOf_FilterType, rhs: Google_Firestore_V1_StructuredQuery.Filter.OneOf_FilterType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.compositeFilter, .compositeFilter): return {
          guard case .compositeFilter(let l) = lhs, case .compositeFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.fieldFilter, .fieldFilter): return {
          guard case .fieldFilter(let l) = lhs, case .fieldFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.unaryFilter, .unaryFilter): return {
          guard case .unaryFilter(let l) = lhs, case .unaryFilter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// A filter that merges multiple other filters using the given operator.
  public struct CompositeFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The operator for combining multiple filters.
    public var op: Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator = .unspecified

    /// The list of filters to combine.
    ///
    /// Requires:
    ///
    /// * At least one filter is present.
    public var filters: [Google_Firestore_V1_StructuredQuery.Filter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A composite filter operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// Documents are required to satisfy all of the combined filters.
      case and // = 1

      /// Documents are required to satisfy at least one of the combined filters.
      case or // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .and
        case 2: self = .or
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .and: return 1
        case .or: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// A filter on a specific field.
  public struct FieldFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field to filter by.
    public var field: Google_Firestore_V1_StructuredQuery.FieldReference {
      get {return _field ?? Google_Firestore_V1_StructuredQuery.FieldReference()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    /// The operator to filter by.
    public var op: Google_Firestore_V1_StructuredQuery.FieldFilter.Operator = .unspecified

    /// The value to compare to.
    public var value: Google_Firestore_V1_Value {
      get {return _value ?? Google_Firestore_V1_Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A field filter operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// The given `field` is less than the given `value`.
      ///
      /// Requires:
      ///
      /// * That `field` come first in `order_by`.
      case lessThan // = 1

      /// The given `field` is less than or equal to the given `value`.
      ///
      /// Requires:
      ///
      /// * That `field` come first in `order_by`.
      case lessThanOrEqual // = 2

      /// The given `field` is greater than the given `value`.
      ///
      /// Requires:
      ///
      /// * That `field` come first in `order_by`.
      case greaterThan // = 3

      /// The given `field` is greater than or equal to the given `value`.
      ///
      /// Requires:
      ///
      /// * That `field` come first in `order_by`.
      case greaterThanOrEqual // = 4

      /// The given `field` is equal to the given `value`.
      case equal // = 5

      /// The given `field` is not equal to the given `value`.
      ///
      /// Requires:
      ///
      /// * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
      /// * That `field` comes first in the `order_by`.
      case notEqual // = 6

      /// The given `field` is an array that contains the given `value`.
      case arrayContains // = 7

      /// The given `field` is equal to at least one value in the given array.
      ///
      /// Requires:
      ///
      /// * That `value` is a non-empty `ArrayValue`, subject to disjunction
      ///   limits.
      /// * No `NOT_IN` filters in the same query.
      case `in` // = 8

      /// The given `field` is an array that contains any of the values in the
      /// given array.
      ///
      /// Requires:
      ///
      /// * That `value` is a non-empty `ArrayValue`, subject to disjunction
      ///   limits.
      /// * No other `ARRAY_CONTAINS_ANY` filters within the same disjunction.
      /// * No `NOT_IN` filters in the same query.
      case arrayContainsAny // = 9

      /// The value of the `field` is not in the given array.
      ///
      /// Requires:
      ///
      /// * That `value` is a non-empty `ArrayValue` with at most 10 values.
      /// * No other `OR`, `IN`, `ARRAY_CONTAINS_ANY`, `NOT_IN`, `NOT_EQUAL`,
      ///   `IS_NOT_NULL`, or `IS_NOT_NAN`.
      /// * That `field` comes first in the `order_by`.
      case notIn // = 10
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .lessThan
        case 2: self = .lessThanOrEqual
        case 3: self = .greaterThan
        case 4: self = .greaterThanOrEqual
        case 5: self = .equal
        case 6: self = .notEqual
        case 7: self = .arrayContains
        case 8: self = .in
        case 9: self = .arrayContainsAny
        case 10: self = .notIn
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .lessThan: return 1
        case .lessThanOrEqual: return 2
        case .greaterThan: return 3
        case .greaterThanOrEqual: return 4
        case .equal: return 5
        case .notEqual: return 6
        case .arrayContains: return 7
        case .in: return 8
        case .arrayContainsAny: return 9
        case .notIn: return 10
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _field: Google_Firestore_V1_StructuredQuery.FieldReference? = nil
    fileprivate var _value: Google_Firestore_V1_Value? = nil
  }

  /// A filter with a single operand.
  public struct UnaryFilter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unary operator to apply.
    public var op: Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator = .unspecified

    /// The argument to the filter.
    public var operandType: Google_Firestore_V1_StructuredQuery.UnaryFilter.OneOf_OperandType? = nil

    /// The field to which to apply the operator.
    public var field: Google_Firestore_V1_StructuredQuery.FieldReference {
      get {
        if case .field(let v)? = operandType {return v}
        return Google_Firestore_V1_StructuredQuery.FieldReference()
      }
      set {operandType = .field(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The argument to the filter.
    public enum OneOf_OperandType: Equatable {
      /// The field to which to apply the operator.
      case field(Google_Firestore_V1_StructuredQuery.FieldReference)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_StructuredQuery.UnaryFilter.OneOf_OperandType, rhs: Google_Firestore_V1_StructuredQuery.UnaryFilter.OneOf_OperandType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.field, .field): return {
          guard case .field(let l) = lhs, case .field(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    /// A unary operator.
    public enum Operator: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified. This value must not be used.
      case unspecified // = 0

      /// The given `field` is equal to `NaN`.
      case isNan // = 2

      /// The given `field` is equal to `NULL`.
      case isNull // = 3

      /// The given `field` is not equal to `NaN`.
      ///
      /// Requires:
      ///
      /// * No other `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
      /// * That `field` comes first in the `order_by`.
      case isNotNan // = 4

      /// The given `field` is not equal to `NULL`.
      ///
      /// Requires:
      ///
      /// * A single `NOT_EQUAL`, `NOT_IN`, `IS_NOT_NULL`, or `IS_NOT_NAN`.
      /// * That `field` comes first in the `order_by`.
      case isNotNull // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 2: self = .isNan
        case 3: self = .isNull
        case 4: self = .isNotNan
        case 5: self = .isNotNull
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .isNan: return 2
        case .isNull: return 3
        case .isNotNan: return 4
        case .isNotNull: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// An order on a field.
  public struct Order {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The field to order by.
    public var field: Google_Firestore_V1_StructuredQuery.FieldReference {
      get {return _field ?? Google_Firestore_V1_StructuredQuery.FieldReference()}
      set {_field = newValue}
    }
    /// Returns true if `field` has been explicitly set.
    public var hasField: Bool {return self._field != nil}
    /// Clears the value of `field`. Subsequent reads from it will return its default value.
    public mutating func clearField() {self._field = nil}

    /// The direction to order by. Defaults to `ASCENDING`.
    public var direction: Google_Firestore_V1_StructuredQuery.Direction = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _field: Google_Firestore_V1_StructuredQuery.FieldReference? = nil
  }

  /// A reference to a field in a document, ex: `stats.operations`.
  public struct FieldReference {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A reference to a field in a document.
    ///
    /// Requires:
    ///
    /// * MUST be a dot-delimited (`.`) string of segments, where each segment
    /// conforms to [document field name][google.firestore.v1.Document.fields]
    /// limitations.
    public var fieldPath: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The projection of document's fields to return.
  public struct Projection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The fields to return.
    ///
    /// If empty, all fields are returned. To only return the name
    /// of the document, use `['__name__']`.
    public var fields: [Google_Firestore_V1_StructuredQuery.FieldReference] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Nearest Neighbors search config. The ordering provided by FindNearest
  /// supersedes the order_by stage. If multiple documents have the same vector
  /// distance, the returned document order is not guaranteed to be stable
  /// between queries.
  public struct FindNearest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. An indexed vector field to search upon. Only documents which
    /// contain vectors whose dimensionality match the query_vector can be
    /// returned.
    public var vectorField: Google_Firestore_V1_StructuredQuery.FieldReference {
      get {return _vectorField ?? Google_Firestore_V1_StructuredQuery.FieldReference()}
      set {_vectorField = newValue}
    }
    /// Returns true if `vectorField` has been explicitly set.
    public var hasVectorField: Bool {return self._vectorField != nil}
    /// Clears the value of `vectorField`. Subsequent reads from it will return its default value.
    public mutating func clearVectorField() {self._vectorField = nil}

    /// Required. The query vector that we are searching on. Must be a vector of
    /// no more than 2048 dimensions.
    public var queryVector: Google_Firestore_V1_Value {
      get {return _queryVector ?? Google_Firestore_V1_Value()}
      set {_queryVector = newValue}
    }
    /// Returns true if `queryVector` has been explicitly set.
    public var hasQueryVector: Bool {return self._queryVector != nil}
    /// Clears the value of `queryVector`. Subsequent reads from it will return its default value.
    public mutating func clearQueryVector() {self._queryVector = nil}

    /// Required. The distance measure to use, required.
    public var distanceMeasure: Google_Firestore_V1_StructuredQuery.FindNearest.DistanceMeasure = .unspecified

    /// Required. The number of nearest neighbors to return. Must be a positive
    /// integer of no more than 1000.
    public var limit: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _limit ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_limit = newValue}
    }
    /// Returns true if `limit` has been explicitly set.
    public var hasLimit: Bool {return self._limit != nil}
    /// Clears the value of `limit`. Subsequent reads from it will return its default value.
    public mutating func clearLimit() {self._limit = nil}

    /// Optional. Optional name of the field to output the result of the vector
    /// distance calculation. Must conform to [document field
    /// name][google.firestore.v1.Document.fields] limitations.
    public var distanceResultField: String = String()

    /// Optional. Option to specify a threshold for which no less similar
    /// documents will be returned. The behavior of the specified
    /// `distance_measure` will affect the meaning of the distance threshold.
    /// Since DOT_PRODUCT distances increase when the vectors are more similar,
    /// the comparison is inverted.
    ///
    /// For EUCLIDEAN, COSINE: WHERE distance <= distance_threshold
    /// For DOT_PRODUCT:       WHERE distance >= distance_threshold
    public var distanceThreshold: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _distanceThreshold ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_distanceThreshold = newValue}
    }
    /// Returns true if `distanceThreshold` has been explicitly set.
    public var hasDistanceThreshold: Bool {return self._distanceThreshold != nil}
    /// Clears the value of `distanceThreshold`. Subsequent reads from it will return its default value.
    public mutating func clearDistanceThreshold() {self._distanceThreshold = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The distance measure to use when comparing vectors.
    public enum DistanceMeasure: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Should not be set.
      case unspecified // = 0

      /// Measures the EUCLIDEAN distance between the vectors. See
      /// [Euclidean](https://en.wikipedia.org/wiki/Euclidean_distance) to learn
      /// more. The resulting distance decreases the more similar two vectors
      /// are.
      case euclidean // = 1

      /// COSINE distance compares vectors based on the angle between them, which
      /// allows you to measure similarity that isn't based on the vectors
      /// magnitude. We recommend using DOT_PRODUCT with unit normalized vectors
      /// instead of COSINE distance, which is mathematically equivalent with
      /// better performance. See [Cosine
      /// Similarity](https://en.wikipedia.org/wiki/Cosine_similarity) to learn
      /// more about COSINE similarity and COSINE distance. The resulting
      /// COSINE distance decreases the more similar two vectors are.
      case cosine // = 2

      /// Similar to cosine but is affected by the magnitude of the vectors. See
      /// [Dot Product](https://en.wikipedia.org/wiki/Dot_product) to learn more.
      /// The resulting distance increases the more similar two vectors are.
      case dotProduct // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .euclidean
        case 2: self = .cosine
        case 3: self = .dotProduct
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .euclidean: return 1
        case .cosine: return 2
        case .dotProduct: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _vectorField: Google_Firestore_V1_StructuredQuery.FieldReference? = nil
    fileprivate var _queryVector: Google_Firestore_V1_Value? = nil
    fileprivate var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    fileprivate var _distanceThreshold: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Firestore_V1_StructuredQuery.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Google_Firestore_V1_StructuredQuery.Direction] = [
    .unspecified,
    .ascending,
    .descending,
  ]
}

extension Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator] = [
    .unspecified,
    .and,
    .or,
  ]
}

extension Google_Firestore_V1_StructuredQuery.FieldFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Google_Firestore_V1_StructuredQuery.FieldFilter.Operator] = [
    .unspecified,
    .lessThan,
    .lessThanOrEqual,
    .greaterThan,
    .greaterThanOrEqual,
    .equal,
    .notEqual,
    .arrayContains,
    .in,
    .arrayContainsAny,
    .notIn,
  ]
}

extension Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator] = [
    .unspecified,
    .isNan,
    .isNull,
    .isNotNan,
    .isNotNull,
  ]
}

extension Google_Firestore_V1_StructuredQuery.FindNearest.DistanceMeasure: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Google_Firestore_V1_StructuredQuery.FindNearest.DistanceMeasure] = [
    .unspecified,
    .euclidean,
    .cosine,
    .dotProduct,
  ]
}

#endif  // swift(>=4.2)

/// Firestore query for running an aggregation over a
/// [StructuredQuery][google.firestore.v1.StructuredQuery].
public struct Google_Firestore_V1_StructuredAggregationQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The base query to aggregate over.
  public var queryType: Google_Firestore_V1_StructuredAggregationQuery.OneOf_QueryType? = nil

  /// Nested structured query.
  public var structuredQuery: Google_Firestore_V1_StructuredQuery {
    get {
      if case .structuredQuery(let v)? = queryType {return v}
      return Google_Firestore_V1_StructuredQuery()
    }
    set {queryType = .structuredQuery(newValue)}
  }

  /// Optional. Series of aggregations to apply over the results of the
  /// `structured_query`.
  ///
  /// Requires:
  ///
  /// * A minimum of one and maximum of five aggregations per query.
  public var aggregations: [Google_Firestore_V1_StructuredAggregationQuery.Aggregation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The base query to aggregate over.
  public enum OneOf_QueryType: Equatable {
    /// Nested structured query.
    case structuredQuery(Google_Firestore_V1_StructuredQuery)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.OneOf_QueryType, rhs: Google_Firestore_V1_StructuredAggregationQuery.OneOf_QueryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.structuredQuery, .structuredQuery): return {
        guard case .structuredQuery(let l) = lhs, case .structuredQuery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Defines an aggregation that produces a single result.
  public struct Aggregation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of aggregation to perform, required.
    public var `operator`: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.OneOf_Operator? = nil

    /// Count aggregator.
    public var count: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count {
      get {
        if case .count(let v)? = `operator` {return v}
        return Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count()
      }
      set {`operator` = .count(newValue)}
    }

    /// Sum aggregator.
    public var sum: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Sum {
      get {
        if case .sum(let v)? = `operator` {return v}
        return Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Sum()
      }
      set {`operator` = .sum(newValue)}
    }

    /// Average aggregator.
    public var avg: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Avg {
      get {
        if case .avg(let v)? = `operator` {return v}
        return Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Avg()
      }
      set {`operator` = .avg(newValue)}
    }

    /// Optional. Optional name of the field to store the result of the
    /// aggregation into.
    ///
    /// If not provided, Firestore will pick a default name following the format
    /// `field_<incremental_id++>`. For example:
    ///
    /// ```
    /// AGGREGATE
    ///   COUNT_UP_TO(1) AS count_up_to_1,
    ///   COUNT_UP_TO(2),
    ///   COUNT_UP_TO(3) AS count_up_to_3,
    ///   COUNT(*)
    /// OVER (
    ///   ...
    /// );
    /// ```
    ///
    /// becomes:
    ///
    /// ```
    /// AGGREGATE
    ///   COUNT_UP_TO(1) AS count_up_to_1,
    ///   COUNT_UP_TO(2) AS field_1,
    ///   COUNT_UP_TO(3) AS count_up_to_3,
    ///   COUNT(*) AS field_2
    /// OVER (
    ///   ...
    /// );
    /// ```
    ///
    /// Requires:
    ///
    /// * Must be unique across all aggregation aliases.
    /// * Conform to [document field name][google.firestore.v1.Document.fields]
    /// limitations.
    public var alias: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of aggregation to perform, required.
    public enum OneOf_Operator: Equatable {
      /// Count aggregator.
      case count(Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count)
      /// Sum aggregator.
      case sum(Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Sum)
      /// Average aggregator.
      case avg(Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Avg)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.OneOf_Operator, rhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.OneOf_Operator) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.count, .count): return {
          guard case .count(let l) = lhs, case .count(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.sum, .sum): return {
          guard case .sum(let l) = lhs, case .sum(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.avg, .avg): return {
          guard case .avg(let l) = lhs, case .avg(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Count of documents that match the query.
    ///
    /// The `COUNT(*)` aggregation function operates on the entire document
    /// so it does not require a field reference.
    public struct Count {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Optional. Optional constraint on the maximum number of documents to
      /// count.
      ///
      /// This provides a way to set an upper bound on the number of documents
      /// to scan, limiting latency, and cost.
      ///
      /// Unspecified is interpreted as no bound.
      ///
      /// High-Level Example:
      ///
      /// ```
      /// AGGREGATE COUNT_UP_TO(1000) OVER ( SELECT * FROM k );
      /// ```
      ///
      /// Requires:
      ///
      /// * Must be greater than zero when present.
      public var upTo: SwiftProtobuf.Google_Protobuf_Int64Value {
        get {return _upTo ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
        set {_upTo = newValue}
      }
      /// Returns true if `upTo` has been explicitly set.
      public var hasUpTo: Bool {return self._upTo != nil}
      /// Clears the value of `upTo`. Subsequent reads from it will return its default value.
      public mutating func clearUpTo() {self._upTo = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _upTo: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    }

    /// Sum of the values of the requested field.
    ///
    /// * Only numeric values will be aggregated. All non-numeric values
    /// including `NULL` are skipped.
    ///
    /// * If the aggregated values contain `NaN`, returns `NaN`. Infinity math
    /// follows IEEE-754 standards.
    ///
    /// * If the aggregated value set is empty, returns 0.
    ///
    /// * Returns a 64-bit integer if all aggregated numbers are integers and the
    /// sum result does not overflow. Otherwise, the result is returned as a
    /// double. Note that even if all the aggregated values are integers, the
    /// result is returned as a double if it cannot fit within a 64-bit signed
    /// integer. When this occurs, the returned value will lose precision.
    ///
    /// * When underflow occurs, floating-point aggregation is non-deterministic.
    /// This means that running the same query repeatedly without any changes to
    /// the underlying values could produce slightly different results each
    /// time. In those cases, values should be stored as integers over
    /// floating-point numbers.
    public struct Sum {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The field to aggregate on.
      public var field: Google_Firestore_V1_StructuredQuery.FieldReference {
        get {return _field ?? Google_Firestore_V1_StructuredQuery.FieldReference()}
        set {_field = newValue}
      }
      /// Returns true if `field` has been explicitly set.
      public var hasField: Bool {return self._field != nil}
      /// Clears the value of `field`. Subsequent reads from it will return its default value.
      public mutating func clearField() {self._field = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _field: Google_Firestore_V1_StructuredQuery.FieldReference? = nil
    }

    /// Average of the values of the requested field.
    ///
    /// * Only numeric values will be aggregated. All non-numeric values
    /// including `NULL` are skipped.
    ///
    /// * If the aggregated values contain `NaN`, returns `NaN`. Infinity math
    /// follows IEEE-754 standards.
    ///
    /// * If the aggregated value set is empty, returns `NULL`.
    ///
    /// * Always returns the result as a double.
    public struct Avg {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The field to aggregate on.
      public var field: Google_Firestore_V1_StructuredQuery.FieldReference {
        get {return _field ?? Google_Firestore_V1_StructuredQuery.FieldReference()}
        set {_field = newValue}
      }
      /// Returns true if `field` has been explicitly set.
      public var hasField: Bool {return self._field != nil}
      /// Clears the value of `field`. Subsequent reads from it will return its default value.
      public mutating func clearField() {self._field = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _field: Google_Firestore_V1_StructuredQuery.FieldReference? = nil
    }

    public init() {}
  }

  public init() {}
}

/// A position in a query result set.
public struct Google_Firestore_V1_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The values that represent a position, in the order they appear in
  /// the order by clause of a query.
  ///
  /// Can contain fewer values than specified in the order by clause.
  public var values: [Google_Firestore_V1_Value] = []

  /// If the position is just before or just after the given values, relative
  /// to the sort order defined by the query.
  public var before: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Firestore_V1_StructuredQuery: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Direction: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.CollectionSelector: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Filter: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Filter.OneOf_FilterType: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.CompositeFilter: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.FieldFilter: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.FieldFilter.Operator: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.UnaryFilter: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.UnaryFilter.OneOf_OperandType: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Order: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.FieldReference: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.Projection: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.FindNearest: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredQuery.FindNearest.DistanceMeasure: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.OneOf_QueryType: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.OneOf_Operator: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Sum: @unchecked Sendable {}
extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Avg: @unchecked Sendable {}
extension Google_Firestore_V1_Cursor: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.v1"

extension Google_Firestore_V1_StructuredQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructuredQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "select"),
    2: .same(proto: "from"),
    3: .same(proto: "where"),
    4: .standard(proto: "order_by"),
    7: .standard(proto: "start_at"),
    8: .standard(proto: "end_at"),
    6: .same(proto: "offset"),
    5: .same(proto: "limit"),
    9: .standard(proto: "find_nearest"),
  ]

  fileprivate class _StorageClass {
    var _select: Google_Firestore_V1_StructuredQuery.Projection? = nil
    var _from: [Google_Firestore_V1_StructuredQuery.CollectionSelector] = []
    var _where: Google_Firestore_V1_StructuredQuery.Filter? = nil
    var _orderBy: [Google_Firestore_V1_StructuredQuery.Order] = []
    var _startAt: Google_Firestore_V1_Cursor? = nil
    var _endAt: Google_Firestore_V1_Cursor? = nil
    var _offset: Int32 = 0
    var _limit: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
    var _findNearest: Google_Firestore_V1_StructuredQuery.FindNearest? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _select = source._select
      _from = source._from
      _where = source._where
      _orderBy = source._orderBy
      _startAt = source._startAt
      _endAt = source._endAt
      _offset = source._offset
      _limit = source._limit
      _findNearest = source._findNearest
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._select) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._from) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._where) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._orderBy) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._limit) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._offset) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._startAt) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._endAt) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._findNearest) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._select {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._from.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._from, fieldNumber: 2)
      }
      try { if let v = _storage._where {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._orderBy.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._orderBy, fieldNumber: 4)
      }
      try { if let v = _storage._limit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._offset != 0 {
        try visitor.visitSingularInt32Field(value: _storage._offset, fieldNumber: 6)
      }
      try { if let v = _storage._startAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._endAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._findNearest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery, rhs: Google_Firestore_V1_StructuredQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._select != rhs_storage._select {return false}
        if _storage._from != rhs_storage._from {return false}
        if _storage._where != rhs_storage._where {return false}
        if _storage._orderBy != rhs_storage._orderBy {return false}
        if _storage._startAt != rhs_storage._startAt {return false}
        if _storage._endAt != rhs_storage._endAt {return false}
        if _storage._offset != rhs_storage._offset {return false}
        if _storage._limit != rhs_storage._limit {return false}
        if _storage._findNearest != rhs_storage._findNearest {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ASCENDING"),
    2: .same(proto: "DESCENDING"),
  ]
}

extension Google_Firestore_V1_StructuredQuery.CollectionSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".CollectionSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "collection_id"),
    3: .standard(proto: "all_descendants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.collectionID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allDescendants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.collectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.collectionID, fieldNumber: 2)
    }
    if self.allDescendants != false {
      try visitor.visitSingularBoolField(value: self.allDescendants, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.CollectionSelector, rhs: Google_Firestore_V1_StructuredQuery.CollectionSelector) -> Bool {
    if lhs.collectionID != rhs.collectionID {return false}
    if lhs.allDescendants != rhs.allDescendants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "composite_filter"),
    2: .standard(proto: "field_filter"),
    3: .standard(proto: "unary_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_StructuredQuery.CompositeFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .compositeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .compositeFilter(v)
        }
      }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery.FieldFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .fieldFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .fieldFilter(v)
        }
      }()
      case 3: try {
        var v: Google_Firestore_V1_StructuredQuery.UnaryFilter?
        var hadOneofValue = false
        if let current = self.filterType {
          hadOneofValue = true
          if case .unaryFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterType = .unaryFilter(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.filterType {
    case .compositeFilter?: try {
      guard case .compositeFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fieldFilter?: try {
      guard case .fieldFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .unaryFilter?: try {
      guard case .unaryFilter(let v)? = self.filterType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.Filter, rhs: Google_Firestore_V1_StructuredQuery.Filter) -> Bool {
    if lhs.filterType != rhs.filterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.CompositeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".CompositeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.CompositeFilter, rhs: Google_Firestore_V1_StructuredQuery.CompositeFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.CompositeFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "AND"),
    2: .same(proto: "OR"),
  ]
}

extension Google_Firestore_V1_StructuredQuery.FieldFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".FieldFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "op"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 2)
    }
    try { if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.FieldFilter, rhs: Google_Firestore_V1_StructuredQuery.FieldFilter) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.op != rhs.op {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.FieldFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    1: .same(proto: "LESS_THAN"),
    2: .same(proto: "LESS_THAN_OR_EQUAL"),
    3: .same(proto: "GREATER_THAN"),
    4: .same(proto: "GREATER_THAN_OR_EQUAL"),
    5: .same(proto: "EQUAL"),
    6: .same(proto: "NOT_EQUAL"),
    7: .same(proto: "ARRAY_CONTAINS"),
    8: .same(proto: "IN"),
    9: .same(proto: "ARRAY_CONTAINS_ANY"),
    10: .same(proto: "NOT_IN"),
  ]
}

extension Google_Firestore_V1_StructuredQuery.UnaryFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".UnaryFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredQuery.FieldReference?
        var hadOneofValue = false
        if let current = self.operandType {
          hadOneofValue = true
          if case .field(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operandType = .field(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.op != .unspecified {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    try { if case .field(let v)? = self.operandType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.UnaryFilter, rhs: Google_Firestore_V1_StructuredQuery.UnaryFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs.operandType != rhs.operandType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.UnaryFilter.Operator: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OPERATOR_UNSPECIFIED"),
    2: .same(proto: "IS_NAN"),
    3: .same(proto: "IS_NULL"),
    4: .same(proto: "IS_NOT_NAN"),
    5: .same(proto: "IS_NOT_NULL"),
  ]
}

extension Google_Firestore_V1_StructuredQuery.Order: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".Order"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
    2: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.Order, rhs: Google_Firestore_V1_StructuredQuery.Order) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.FieldReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".FieldReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "field_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.fieldPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.FieldReference, rhs: Google_Firestore_V1_StructuredQuery.FieldReference) -> Bool {
    if lhs.fieldPath != rhs.fieldPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.Projection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".Projection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.Projection, rhs: Google_Firestore_V1_StructuredQuery.Projection) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.FindNearest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredQuery.protoMessageName + ".FindNearest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vector_field"),
    2: .standard(proto: "query_vector"),
    3: .standard(proto: "distance_measure"),
    4: .same(proto: "limit"),
    5: .standard(proto: "distance_result_field"),
    6: .standard(proto: "distance_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._vectorField) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._queryVector) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.distanceMeasure) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.distanceResultField) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._distanceThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._vectorField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._queryVector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.distanceMeasure != .unspecified {
      try visitor.visitSingularEnumField(value: self.distanceMeasure, fieldNumber: 3)
    }
    try { if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.distanceResultField.isEmpty {
      try visitor.visitSingularStringField(value: self.distanceResultField, fieldNumber: 5)
    }
    try { if let v = self._distanceThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredQuery.FindNearest, rhs: Google_Firestore_V1_StructuredQuery.FindNearest) -> Bool {
    if lhs._vectorField != rhs._vectorField {return false}
    if lhs._queryVector != rhs._queryVector {return false}
    if lhs.distanceMeasure != rhs.distanceMeasure {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.distanceResultField != rhs.distanceResultField {return false}
    if lhs._distanceThreshold != rhs._distanceThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredQuery.FindNearest.DistanceMeasure: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISTANCE_MEASURE_UNSPECIFIED"),
    1: .same(proto: "EUCLIDEAN"),
    2: .same(proto: "COSINE"),
    3: .same(proto: "DOT_PRODUCT"),
  ]
}

extension Google_Firestore_V1_StructuredAggregationQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructuredAggregationQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "structured_query"),
    3: .same(proto: "aggregations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_StructuredQuery?
        var hadOneofValue = false
        if let current = self.queryType {
          hadOneofValue = true
          if case .structuredQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.queryType = .structuredQuery(v)
        }
      }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.aggregations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .structuredQuery(let v)? = self.queryType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.aggregations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery, rhs: Google_Firestore_V1_StructuredAggregationQuery) -> Bool {
    if lhs.queryType != rhs.queryType {return false}
    if lhs.aggregations != rhs.aggregations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredAggregationQuery.protoMessageName + ".Aggregation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "sum"),
    3: .same(proto: "avg"),
    7: .same(proto: "alias"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count?
        var hadOneofValue = false
        if let current = self.`operator` {
          hadOneofValue = true
          if case .count(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`operator` = .count(v)
        }
      }()
      case 2: try {
        var v: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Sum?
        var hadOneofValue = false
        if let current = self.`operator` {
          hadOneofValue = true
          if case .sum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`operator` = .sum(v)
        }
      }()
      case 3: try {
        var v: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Avg?
        var hadOneofValue = false
        if let current = self.`operator` {
          hadOneofValue = true
          if case .avg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.`operator` = .avg(v)
        }
      }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.alias) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.`operator` {
    case .count?: try {
      guard case .count(let v)? = self.`operator` else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .sum?: try {
      guard case .sum(let v)? = self.`operator` else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .avg?: try {
      guard case .avg(let v)? = self.`operator` else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.alias.isEmpty {
      try visitor.visitSingularStringField(value: self.alias, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation, rhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation) -> Bool {
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.alias != rhs.alias {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredAggregationQuery.Aggregation.protoMessageName + ".Count"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "up_to"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._upTo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upTo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count, rhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Count) -> Bool {
    if lhs._upTo != rhs._upTo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Sum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredAggregationQuery.Aggregation.protoMessageName + ".Sum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Sum, rhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Sum) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Avg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Firestore_V1_StructuredAggregationQuery.Aggregation.protoMessageName + ".Avg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._field) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._field {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Avg, rhs: Google_Firestore_V1_StructuredAggregationQuery.Aggregation.Avg) -> Bool {
    if lhs._field != rhs._field {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .same(proto: "before"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.before) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    if self.before != false {
      try visitor.visitSingularBoolField(value: self.before, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Firestore_V1_Cursor, rhs: Google_Firestore_V1_Cursor) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.before != rhs.before {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
